=== Header ===

<!-- perl utils\wiki_schema.pl sql\schema.wiki 1 > sql\schema.sql -->
<!-- PARSE PART DBCREATE BEGIN -->
<source lang=sql>
-- schema version: 0.09
SET FOREIGN_KEY_CHECKS=0;
start transaction;
</source>

=== Tables ===

==== user ====
User info.
* user_id
* login
* passwd
* first_name
* last_name
* active - 0 means historical data
* created - account creation date
* last_login - date
<source lang=sql>
CREATE TABLE user (
    user_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    login       VARCHAR(20) NOT NULL,
    passwd      VARCHAR(20) NOT NULL,
    first_name  VARCHAR(255) NOT NULL DEFAULT '',
    last_name   VARCHAR(255) NOT NULL DEFAULT '',
    active      BOOLEAN NOT NULL DEFAULT 1,
    created     DATETIME NOT NULL,
    last_login  DATETIME DEFAULT NULL,
    INDEX i_login (login)
) TYPE=InnoDB;
</source>

==== machine (m) ====
machine (computer) info.
* machine_id
* user_id
* name
* passwd
* desc - description
* ip
* cpuarch
* osname
* archname
* disabled
* created
* prev_machine_id
<source lang=sql>
CREATE TABLE machine (
    machine_id      INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    user_id         INT UNSIGNED NOT NULL,
    name            VARCHAR(20) NOT NULL,
    passwd          VARCHAR(20) NOT NULL,
    `desc`          TEXT DEFAULT NULL,
    ip              VARCHAR(15) DEFAULT NULL,
    cpuarch         VARCHAR(50) DEFAULT NULL,
    osname          VARCHAR(50) DEFAULT NULL,
    archname        VARCHAR(255) DEFAULT NULL,
    disabled        BOOLEAN NOT NULL DEFAULT 0,
    created         DATETIME NOT NULL,
    prev_machine_id INT UNSIGNED DEFAULT NULL,
    farm_id         INT UNSIGNED DEFAULT NULL,
    CONSTRAINT fk_machine_user_id FOREIGN KEY (user_id) REFERENCES user (user_id),
    CONSTRAINT fk_machine_prev_machine_id FOREIGN KEY (prev_machine_id) REFERENCES machine (machine_id),
    CONSTRAINT fk_machine_farm_id FOREIGN KEY (farm_id) REFERENCES farm (farm_id)
) TYPE=InnoDB;
</source>

==== farm ====
Group of machines with same HW, SW or both configurations working in farm.
* farm_id
* name
* has_same_hw
* has_same_sw
* desc
<source lang=sql>
CREATE TABLE farm (
    farm_id         INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(30) NOT NULL,
    has_same_hw     BOOLEAN NOT NULL DEFAULT 0,
    has_same_sw     BOOLEAN NOT NULL DEFAULT 0,
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== project ====
Project.
* project_id
* name
* url
* desc
<source lang=sql>
CREATE TABLE project (
    project_id  INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name        VARCHAR(255) NOT NULL,
    url         VARCHAR(255) NOT NULL,
    `desc`      TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== rep ====
Project repository. Each project can has only one active repository.
* rep_id
* project_id
* name
* path
* desc
* active - 1 .. repository is active, 0 .. old (deprecated) repository
* default_layout - Has default Subversion repository layout (trunk, tags, branches).
<source lang=sql>
CREATE TABLE rep (
    rep_id          INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    project_id      INT UNSIGNED NOT NULL,
    name            VARCHAR(255) NOT NULL,
    path            VARCHAR(255) NOT NULL,
    `desc`          TEXT DEFAULT NULL,
    active          BOOLEAN NOT NULL DEFAULT 1,
    default_layout  BOOLEAN NOT NULL DEFAULT 1,
    CONSTRAINT fk_rep_project_id FOREIGN KEY (project_id) REFERENCES project (project_id),
    UNIQUE KEY unique_rep_id_path (rep_id, path)
) TYPE=InnoDB;
</source>

==== rep_author ====
Repository and patch authors. Some authors are also users.
* rep_author_id
* rep_id
* rep_login - can be null, see parrot rev 1346 created by cvs2svn
* user_id - some authors has TapTinder user_id too.
<source lang=sql>
CREATE TABLE rep_author (
    rep_author_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_id          INT UNSIGNED NOT NULL,
    rep_login       VARCHAR(255) DEFAULT NULL,
    user_id         INT UNSIGNED DEFAULT NULL,
    INDEX i_rep_id (rep_id),
    INDEX i_rep_login (rep_login),
    INDEX i_user_id (user_id),
    CONSTRAINT fk_user_rep_rep_id FOREIGN KEY (rep_id) REFERENCES rep (rep_id),
    CONSTRAINT fk_user_rep_user_id FOREIGN KEY (user_id) REFERENCES user (user_id)
) TYPE=InnoDB;
</source>

==== rev ====
Revision info.
* rev_id
* rep_id - cache for rev_rep_path.rep_path_id -> rep_path.rep_id
* rev_num
* author_id
* date
* msg
<source lang=sql>
CREATE TABLE rev (
    rev_id          INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_id          INT UNSIGNED NOT NULL,
    rev_num         INT UNSIGNED NOT NULL,
    author_id       INT UNSIGNED NOT NULL,
    date            DATETIME NOT NULL,
    msg             TEXT,
    INDEX i_rep_id (rep_id),
    INDEX i_rev_num (rev_num),
    CONSTRAINT fk_rev_rep_id FOREIGN KEY (rep_id) REFERENCES rep (rep_id),
    CONSTRAINT fk_rev_rep_author_id FOREIGN KEY (author_id) REFERENCES rep_author (rep_author_id)
) TYPE=InnoDB;
</source>

==== rep_path ====
Repository path (trunk/, branch/pdd17pmc/, ...).
* rep_path_id
* rep_id
* path
* rev_num_from
* rev_num_to
<source lang=sql>
CREATE TABLE rep_path (
    rep_path_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_id          INT UNSIGNED NOT NULL,
    path            VARCHAR(255) NOT NULL,
    rev_num_from    INT UNSIGNED NOT NULL,
    rev_num_to      INT UNSIGNED DEFAULT NULL,
    INDEX i_rep_id (rep_id),
    INDEX i_path (path),
    INDEX i_rev_num_from (rev_num_from),
    INDEX i_rev_num_to (rev_num_to),
    CONSTRAINT fk_rep_path_rep_id FOREIGN KEY (rep_id) REFERENCES rep (rep_id)
) TYPE=InnoDB;
</source>

==== rev_rep_path ====
Revision info to repository path map (M:N).
* rev_id
* rep_path_id
<source lang=sql>
CREATE TABLE rev_rep_path (
    rev_id              INT UNSIGNED NOT NULL,
    rep_path_id         INT UNSIGNED NOT NULL,
    UNIQUE KEY unique_rep_id_path (rev_id, rep_path_id),
    CONSTRAINT fk_rev_rep_path_rev_id FOREIGN KEY (rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_rev_rep_path_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id)
) TYPE=InnoDB;
</source>

==== rep_file ====
Files in repository path.
* rep_file_id
* rep_path_id
* sub_path
* rev_num_from - revision where this file was added
* rev_num_to - revision number where this file was last seen (file was deleted in rev_to+1 revision)
<source lang=sql>
CREATE TABLE rep_file (
    rep_file_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_path_id     INT UNSIGNED NOT NULL,
    sub_path        VARCHAR(255) NOT NULL,
    rev_num_from    INT UNSIGNED NOT NULL,
    rev_num_to      INT UNSIGNED DEFAULT NULL,
    INDEX i_rep_path_id (rep_path_id),
    INDEX i_rev_num_from (rev_num_from),
    INDEX i_rev_num_to (rev_num_to),
    CONSTRAINT fk_rep_file_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id)
) TYPE=InnoDB;
</source>

==== rep_change_type ====
Change types and info.
* rep_change_type_id
* abbr
* desc
<source lang=sql>
CREATE TABLE rep_change_type (
    rep_change_type_id  INT UNSIGNED NOT NULL PRIMARY KEY,
    abbr                VARCHAR(1) NOT NULL,
    `desc`              VARCHAR(10) NOT NULL,
    INDEX i_abbr (abbr)
) TYPE=InnoDB;
</source>

==== rep_file_change ====
* rev_id
* rev_num - cache for rev.rev_num
* rep_file_id
* change_type_id
<source lang=sql>
CREATE TABLE rep_file_change (
    rev_id          INT UNSIGNED NOT NULL,
    rev_num         INT UNSIGNED NOT NULL,
    rep_file_id     INT UNSIGNED NOT NULL,
    change_type_id  INT UNSIGNED NOT NULL,
    INDEX i_rev_id (rev_id),
    INDEX i_rev_num (rev_num),
    INDEX i_rev_id_rep_file_id (rev_id, rep_file_id),
    CONSTRAINT fk_rep_file_change_rev_id FOREIGN KEY (rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_rep_file_change_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id),
    CONSTRAINT fk_rep_file_change_change_type_id FOREIGN KEY (change_type_id) REFERENCES rep_change_type (rep_change_type_id)
) TYPE=InnoDB;
</source>

==== rep_file_change_from ====
* rev_id
* rep_file_id
* from_rev_id
* from_rep_file_id
<source lang=sql>
CREATE TABLE rep_file_change_from (
    rev_id              INT UNSIGNED NOT NULL,
    rep_file_id         INT UNSIGNED NOT NULL,
    from_rev_id         INT UNSIGNED DEFAULT NULL,
    from_rep_file_id    INT UNSIGNED DEFAULT NULL,
    INDEX i_rev_id_rep_file_id (rev_id, rep_file_id),
    CONSTRAINT fk_rep_file_change_from_rev_id FOREIGN KEY (rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_rep_file_change_from_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id),
    CONSTRAINT fk_rep_file_change_from_from_rev_id FOREIGN KEY (from_rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_rep_file_change_from_from_rep_file_id FOREIGN KEY (from_rep_file_id) REFERENCES rep_file (rep_file_id)
) TYPE=InnoDB;
</source>

==== patch ====
Only one file for each patch.
* patch_id
* rep_path_id
* rev_num - revison number found in patch
* rev_num_to - cache, server checks if patch apply ok
* author_id
* date
* msg
* file_id
* new_patch_id - if not null then patch has newer version
<source lang=sql>
CREATE TABLE patch (
    patch_id        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_path_id     INT UNSIGNED NOT NULL,
    rev_num         INT UNSIGNED NOT NULL,
    rev_num_to      INT UNSIGNED NOT NULL,
    author_id       INT UNSIGNED NOT NULL,
    date            DATETIME NOT NULL,
    msg             TEXT,
    fsfile_id       INT UNSIGNED NOT NULL,
    new_patch_id    INT UNSIGNED DEFAULT NULL,
    INDEX i_rep_path_id (rep_path_id),
    INDEX i_rev_num (rev_num),
    CONSTRAINT fk_patch_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id),
    CONSTRAINT fk_patch_rep_author_id FOREIGN KEY (author_id) REFERENCES rep_author (rep_author_id),
    CONSTRAINT fk_patch_file_id FOREIGN KEY (fsfile_id) REFERENCES fsfile (fsfile_id),
    CONSTRAINT fk_patch_new_patch_id FOREIGN KEY (new_patch_id) REFERENCES patch (patch_id)
) TYPE=InnoDB;
</source>

==== rep_test ====
Number and name of the test. Each rep_file can contains many tests. Rep file gets new id after each file change.
* rep_test_id
* rep_file_id
* number - this test number in rep_file
* name - first inserted, name of the test (if any and not empty)
* has_another_name - 1 if another name was found
<source lang=sql>
CREATE TABLE rep_test (
    rep_test_id         INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_file_id         INT UNSIGNED NOT NULL,
    number              INT UNSIGNED NOT NULL,
    name                VARCHAR(255) NOT NULL,
    has_another_name    BOOLEAN NOT NULL DEFAULT 0,
    INDEX i_rep_file_id (rep_file_id),
    INDEX i_rep_file_id_number (rep_file_id, number),
    CONSTRAINT fk_rep_test_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id)
) TYPE=InnoDB;
</source>

==== job ====
Job. Job table can contain one part or more related parts.
* job_id
* client_min_rev - minimal clietn revision number to run this job
*
* name
* desc
<source lang=sql>
CREATE TABLE job (
    job_id          INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    client_min_rev  INT UNSIGNED DEFAULT 1,
    priority        INT UNSIGNED NOT NULL DEFAULT 1,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== jobp ====
Job part.
* jobp_id
* job_id
* rep_path_id
* order
* name
* desc
* max_age - Maximal commit age in hours.
* depends_on_id - Depends on jobp.jobp_id. Job part (jobp_id) can't start if jobp.depends_on_id doesn't finished ok.
* extends - Default 0. 1 if this part extends part defined in depends_on_id.
<source lang=sql>
CREATE TABLE jobp (
    jobp_id         INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    job_id          INT UNSIGNED NOT NULL,
    rep_path_id     INT UNSIGNED DEFAULT NULL,
    `order`         INT UNSIGNED NOT NULL,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL,
    max_age         INT UNSIGNED DEFAULT NULL,
    depends_on_id   INT UNSIGNED DEFAULT NULL,
    extends         BOOLEAN NOT NULL DEFAULT 0,
    INDEX i_job_id (job_id),
    INDEX i_rep_path_id (rep_path_id),
    CONSTRAINT fk_jobp_job_id FOREIGN KEY (job_id) REFERENCES job (job_id),
    CONSTRAINT fk_jobp_depedns_on_id FOREIGN KEY (depends_on_id) REFERENCES jobp (jobp_id),
    CONSTRAINT fk_jobp_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id)
) TYPE=InnoDB;
</source>

==== cmd ====
Command.
* cmd_id
* name
* desc
* params
Client should known what to run for each cmd_id. E.g. 1 (perlconf) means run 'perl Configure.pl' or 'perl.exe Configure.pl' (under win32). Server shoul know, which params client needs.
<source lang=sql>
CREATE TABLE cmd (
    cmd_id      INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name        VARCHAR(25),
    `desc`      TEXT DEFAULT NULL,
    params      TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== jobp_cmd ====
Job part command.
* jobp_cmd_id
* jobp_id
* order
* cmd_id
* params
<source lang=sql>
CREATE TABLE jobp_cmd (
    jobp_cmd_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    jobp_id         INT UNSIGNED NOT NULL,
    `order`         INT UNSIGNED NOT NULL,
    cmd_id          INT UNSIGNED NOT NULL,
    params          TEXT,
    INDEX i_jobp_id (jobp_id),
    CONSTRAINT fk_jobp_cmd_jobp_id FOREIGN KEY (jobp_id) REFERENCES jobp (jobp_id),
    CONSTRAINT fk_jobp_cmd_cmd_id FOREIGN KEY (cmd_id) REFERENCES cmd (cmd_id)
) TYPE=InnoDB;
</source>

==== cmd_status ====
Command status.
* cmd_status_id
* name
* 1 .. created -- created in DB, not started yet
* 2 .. running
* 3 .. paused -- paused by user
* 4 .. ok -- finished ok
* 5 .. interrupted
* 6 .. error -- finished with error
* desc
<source lang=sql>
CREATE TABLE cmd_status (
    cmd_status_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== machine_job_conf ====
Machine job configuration.
Defined rep_id is the most general config. Defined job_id the most specific config.
* machine_job_conf_id
* machine_id
* rep_id
* rep_path_id
* job_id
* priority
* allow_patches
<source lang=sql>
CREATE TABLE machine_job_conf (
    machine_job_conf_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    machine_id          INT UNSIGNED NOT NULL,
    rep_id              INT UNSIGNED DEFAULT NULL,
    rep_path_id         INT UNSIGNED DEFAULT NULL,
    job_id              INT UNSIGNED DEFAULT NULL,
    priority            INT UNSIGNED NOT NULL DEFAULT 1,
    allow_patches       BOOLEAN NOT NULL DEFAULT 0,
    INDEX i_machine_id (machine_id),
    CONSTRAINT fk_machine_job_conf_machine_id FOREIGN KEY (machine_id) REFERENCES machine (machine_id),
    CONSTRAINT fk_machine_job_conf_rep_id FOREIGN KEY (rep_id) REFERENCES rep (rep_id),
    CONSTRAINT fk_machine_job_conf_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id),
    CONSTRAINT fk_machine_job_conf_job_id FOREIGN KEY (job_id) REFERENCES job (job_id)
) TYPE=InnoDB;
</source>

==== msession (ms) ====
Machine session. Each machine can run more than one processes at a time.
* msession_id
* machine_id
* client_rev - client revision (11, 10:12M, ...)
* pid - system process id on machine
* start_time - time when machine session was started
* end_time - time when machine session ended
* abort_reason_id - default null, fk to msession_abort_reason
<source lang=sql>
CREATE TABLE msession (
    msession_id         INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    machine_id          INT UNSIGNED NOT NULL,
    client_rev          VARCHAR(21) NOT NULL,
    pid                 INT UNSIGNED DEFAULT NULL,
    start_time          DATETIME NOT NULL,
    end_time            DATETIME DEFAULT NULL,
    abort_reason_id     INT UNSIGNED DEFAULT NULL,
    INDEX i_machine_id (machine_id),
    CONSTRAINT fk_msession_machine_id FOREIGN KEY (machine_id) REFERENCES machine (machine_id),
    CONSTRAINT fk_msession_abort_reason_id FOREIGN KEY (abort_reason_id) REFERENCES msabort_reason (msabort_reason_id)
) TYPE=InnoDB;
</source>

==== msjob ====
Machine session job part.
* msjob_id
* msession_id
* job_id
* start_time - time when machine job was created
* end_time - time when machine job ended
* pid
Abort reason is determined by msession.
<source lang=sql>
CREATE TABLE msjob (
    msjob_id            INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msession_id         INT UNSIGNED NOT NULL,
    job_id              INT UNSIGNED NOT NULL,
    start_time          DATETIME NOT NULL,
    end_time            DATETIME DEFAULT NULL,
    pid                 INT UNSIGNED DEFAULT NULL,
    INDEX i_msession_id (msession_id),
    INDEX i_job_id (job_id),
    CONSTRAINT fk_msjob_msession_id FOREIGN KEY (msession_id) REFERENCES msession (msession_id),
    CONSTRAINT fk_msjob_job_id FOREIGN KEY (job_id) REFERENCES job (job_id)
) TYPE=InnoDB;
</source>

==== msjobp ====
Machine session job part.
* msjobp_id
* msjob_id
* jobp_id
* rev_id
* patch_id
* start_time - time when machine job part was created
* end_time - time when machine job part ended
<source lang=sql>
CREATE TABLE msjobp (
    msjobp_id       INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msjob_id        INT UNSIGNED NOT NULL,
    jobp_id         INT UNSIGNED NOT NULL,
    rev_id          INT UNSIGNED NOT NULL,
    patch_id        INT UNSIGNED DEFAULT NULL,
    start_time      DATETIME NOT NULL,
    end_time        DATETIME DEFAULT NULL,
    INDEX i_msjob_id (msjob_id),
    INDEX i_jobp_id (jobp_id),
    INDEX i_rev_id (rev_id),
    CONSTRAINT fk_msjobp_msjob_id FOREIGN KEY (msjob_id) REFERENCES msjob (msjob_id),
    CONSTRAINT fk_msjobp_jobp_id FOREIGN KEY (jobp_id) REFERENCES jobp (jobp_id),
    CONSTRAINT fk_msjobp_rev_id FOREIGN KEY (rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_msjobp_patch_id FOREIGN KEY (patch_id) REFERENCES patch (patch_id)
) TYPE=InnoDB;
</source>

==== msjobp_cmd ====
Machine session job part command.
* msjobp_cmd_id
* msjobp_id
* jobp_cmd_id
* cmd_status_id
* pid
* start_time
* end_time
* output_id - command output (stderr and stdout, .txt file)
* outdata_id - command data output (one .tar.gz file)
<source lang=sql>
CREATE TABLE msjobp_cmd (
    msjobp_cmd_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msjobp_id       INT UNSIGNED NOT NULL,
    jobp_cmd_id     INT UNSIGNED NOT NULL,
    status_id       INT UNSIGNED NOT NULL,
    pid             INT UNSIGNED DEFAULT NULL,
    start_time      DATETIME NOT NULL,
    end_time        DATETIME DEFAULT NULL,
    output_id       INT UNSIGNED DEFAULT NULL,
    outdata_id      INT UNSIGNED DEFAULT NULL,
    INDEX i_msjobp_id (msjobp_id),
    INDEX i_jobp_cmd_id (jobp_cmd_id),
    CONSTRAINT fk_msjobp_cmd_msjobp_id FOREIGN KEY (msjobp_id) REFERENCES msjobp (msjobp_id),
    CONSTRAINT fk_msjobp_cmd_jobp_cmd_id FOREIGN KEY (jobp_cmd_id) REFERENCES jobp_cmd (jobp_cmd_id),
    CONSTRAINT fk_msjobp_cmd_job_status_id FOREIGN KEY (status_id) REFERENCES cmd_status (cmd_status_id),
    CONSTRAINT fk_msjobp_cmd_output_id FOREIGN KEY (output_id) REFERENCES fsfile (fsfile_id),
    CONSTRAINT fk_msjobp_cmd_outdata_id FOREIGN KEY (outdata_id) REFERENCES fsfile (fsfile_id)
) TYPE=InnoDB;
</source>

==== mslog ====
Machine session log. Could be part of msession table, but separate table is better for logging (and log cleaning).
* mslog_id
* msession_id
* msstatus_id
* attempt_number
* change_time - time when machine change msession state to this status_id
* estimated_finish_time - time when machine will probably change msession status again
** msstatus_id could stay same (waiting for new job) but attempt_number is increased
<source lang=sql>
CREATE TABLE mslog (
    mslog_id                INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msession_id             INT UNSIGNED NOT NULL,
    msstatus_id             INT UNSIGNED NOT NULL,
    attempt_number          INT UNSIGNED DEFAULT 1,
    change_time             DATETIME NOT NULL,
    estimated_finish_time   DATETIME DEFAULT NULL,
    INDEX i_msession_id (msession_id),
    CONSTRAINT fk_mslog_msession_id FOREIGN KEY (msession_id) REFERENCES msession (msession_id),
    CONSTRAINT fk_mslog_msstatus_id FOREIGN KEY (msstatus_id) REFERENCES msstatus (msstatus_id)
) TYPE=InnoDB;
</source>

==== msstatus ====
Machine session status messages.
* msstatus_id
* name - short status description
** 1 .. unknown status
** 2 .. msession just created
** 3 .. waiting for new job
** 4 .. command preparation
** 5 .. running command
** 6 .. paused by user
** 7 .. stop by user
** 8 .. stop by web server -- see also msabort_reason table
** 9 .. stop by anything else
* desc - long description
<source lang=sql>
CREATE TABLE msstatus (
    msstatus_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== msabort_reason ====
Machine session status messages.
* msabort_reason_id
* name - short abort reason description
** 1 .. unknown reason
** 2 .. deprecated client revision
** 3 .. machine was disabled
** 4 .. bad client behavior
** 5 .. iterrupted by user
* desc - long reason description
<source lang=sql>
CREATE TABLE msabort_reason (
    msabort_reason_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name                VARCHAR(25),
    `desc`              TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

=== trun_status ===
Test run loading status.
* trun_status_id
* name
* desc
<source lang=sql>
CREATE TABLE trun_status (
    trun_status_id      INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name                VARCHAR(25),
    `desc`              TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== trun ====
Test run info and test run statistics (cache).
* trun_id
* msjobp_cmd_id
* trun_status_id
* parse_errors  - ttest sum cache
* not_seen - ttest sum cache
* failed - ttest sum cache
* todo - ttest sum cache
* skip - ttest sum cache
* bonus - ttest sum cache
* ok - ttest sum cache
<source lang=sql>
CREATE TABLE trun (
    trun_id         INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msjobp_cmd_id   INT UNSIGNED NOT NULL,
    trun_status_id  INT UNSIGNED NOT NULL,
    parse_errors    INT UNSIGNED NOT NULL,
    not_seen        INT UNSIGNED NOT NULL,
    failed          INT UNSIGNED NOT NULL,
    todo            INT UNSIGNED NOT NULL,
    skip            INT UNSIGNED NOT NULL,
    bonus           INT UNSIGNED NOT NULL,
    ok              INT UNSIGNED NOT NULL,
    INDEX i_msjobp_cmd_id (msjobp_cmd_id),
    CONSTRAINT fk_trun_trun_status_id FOREIGN KEY (trun_status_id) REFERENCES trun_status (trun_status_id),
    CONSTRAINT fk_trun_msjobp_cmd_id FOREIGN KEY (msjobp_cmd_id) REFERENCES msjobp_cmd (msjobp_cmd_id)
) TYPE=InnoDB;
</source>

==== brun_conf ====
Benchmark run.
* brun_conf_id
* hash
* args
* alias_conf_id - another conf with the same semantics, but different syntax
<source lang=sql>
CREATE TABLE brun_conf (
    brun_conf_id    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    hash            VARCHAR(50) NOT NULL,
    args            VARCHAR(255) DEFAULT NULL,
    alias_conf_id   INT UNSIGNED DEFAULT NULL,
    INDEX i_hash (hash),
    CONSTRAINT fk_brun_conf_alias_conf_id FOREIGN KEY (alias_conf_id) REFERENCES brun_conf (brun_conf_id)
) TYPE=InnoDB;
</source>

==== brun ====
* brun_id
* msjobp_cmd_id
* conf_id
<source lang=sql>
CREATE TABLE brun (
    brun_id         INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msjobp_cmd_id   INT UNSIGNED NOT NULL,
    conf_id         INT UNSIGNED NOT NULL,
    INDEX i_msjobp_cmd_id (msjobp_cmd_id),
    INDEX i_conf_id (conf_id),
    CONSTRAINT fk_brun_msjobp_cmd_id FOREIGN KEY (msjobp_cmd_id) REFERENCES msjobp_cmd (msjobp_cmd_id),
    CONSTRAINT fk_brun_conf_id FOREIGN KEY (conf_id) REFERENCES brun_conf (brun_conf_id)
) TYPE=InnoDB;
</source>

==== tskipall_msg ====
Reasons to skipp all tests.
* tskippall_msg_id
* msg
* hash
<source lang=sql>
CREATE TABLE tskipall_msg (
    tskipall_msg_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msg                 TEXT,
    hash                VARCHAR(50) NOT NULL,
    INDEX i_hash (hash)
) TYPE=InnoDB;
</source>

==== tfile ====
Test file summary results - summary result for all tests in file. All_passed is shortcup to data test.
* tfile_id
* trun_id
* rep_file_id
* all_passed -- (in Harness::Straps max == seen == ok)
* tskippall_msg_id (can be null)
* hang - if test hang and was killed
<source lang=sql>
CREATE TABLE tfile (
    tfile_id            INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    trun_id             INT UNSIGNED NOT NULL,
    rep_file_id         INT UNSIGNED NOT NULL,
    all_passed          BOOLEAN NOT NULL DEFAULT 0,
    tskipall_msg_id     INT UNSIGNED DEFAULT NULL,
    hang                BOOLEAN DEFAULT 0,
    INDEX i_trun_id (trun_id),
    CONSTRAINT fk_tfile_trun_id FOREIGN KEY (trun_id) REFERENCES trun (trun_id),
    CONSTRAINT fk_tfile_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id),
    CONSTRAINT fk_tfile_tskipall_msg_id FOREIGN KEY (tskipall_msg_id) REFERENCES tskipall_msg (tskipall_msg_id)
) TYPE=InnoDB;
</source>

==== trest ====
Test result info.
* tresult_id
* name
** 1 .. not seen
** 2 .. failed
** 3 .. unknown
** 4 .. todo
** 5 .. bonus -- unexpectedly succeeded
** 6 .. skip
** 7 .. ok
* desc
<source lang=sql>
CREATE TABLE trest (
    trest_id    INT UNSIGNED NOT NULL PRIMARY KEY,
    name        VARCHAR(25),
    `desc`      TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== ttest ====
Test results for each test (test case, subtest) submitted in trun.
* ttest_id
* trun_id
* rep_test_id
* trest_id
<source lang=sql>
CREATE TABLE ttest (
    ttest_id        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    trun_id         INT UNSIGNED NOT NULL,
    rep_test_id     INT UNSIGNED NOT NULL,
    trest_id        INT UNSIGNED NOT NULL,
    INDEX i_rep_test_id (rep_test_id),
    INDEX i_trun_id (trun_id),
    INDEX i_trest_id (trest_id),
    CONSTRAINT fk_ttest_trun_id FOREIGN KEY (trun_id) REFERENCES trun (trun_id),
    CONSTRAINT fk_ttest_rep_test_id FOREIGN KEY (rep_test_id) REFERENCES rep_test (rep_test_id),
    CONSTRAINT fk_ttest_trest_id FOREIGN KEY (trest_id) REFERENCES trest (trest_id)
) TYPE=InnoDB;
</source>

==== tdiag_msg ====
Diagnostic messages.
* tdiag_msg_id
* ttest_id
* msg
* hash
<source lang=sql>
CREATE TABLE tdiag_msg (
    tdiag_msg_id    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    ttest_id        INT UNSIGNED NOT NULL,
    msg             TEXT,
    hash            VARCHAR(50) NOT NULL,
    INDEX i_ttest_id (ttest_id),
    INDEX i_hash (hash),
    CONSTRAINT fk_tdiag_msg_ttest_id FOREIGN KEY (ttest_id) REFERENCES ttest (ttest_id)
) TYPE=InnoDB;
</source>

==== bfile ====
Bench file results.
* bfile_id
* brun_id
* rep_file_id
* run_time
* hang - if test hang and was killed
<source lang=sql>
CREATE TABLE bfile (
    bfile_id            INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    brun_id             INT UNSIGNED NOT NULL,
    rep_file_id         INT UNSIGNED NOT NULL,
    run_time            INT UNSIGNED DEFAULT NULL,
    hang                BOOLEAN DEFAULT 0,
    INDEX i_brun_id (brun_id),
    CONSTRAINT fk_bfile_brun_id FOREIGN KEY (brun_id) REFERENCES brun (brun_id),
    CONSTRAINT fk_bfile_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id)
) TYPE=InnoDB;
</source>

==== fspath ====
List of directories with files.
* fspath_id
* path - full path from root, e.g. /tmp/taptinder/patches/parrot-01/
* web_path
* public
* created
* deleted
* name
* desc
<source lang=sql>
CREATE TABLE fspath (
    fspath_id       INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    path            VARCHAR(1023),
    web_path        VARCHAR(255),
    public          BOOLEAN DEFAULT 0,
    created         DATETIME NOT NULL,
    deleted         DATETIME DEFAULT NULL,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== fsfile ====
List of saved files.
* fsfile_id
* fspath_id
* name
* size -- in bytes
* created
* deleted
<source lang=sql>
CREATE TABLE fsfile (
    fsfile_id       INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    fspath_id       INT UNSIGNED NOT NULL,
    name            VARCHAR(255),
    size            INT UNSIGNED NOT NULL,
    created         DATETIME NOT NULL,
    deleted         DATETIME DEFAULT NULL,
    INDEX i_fspath_id (fspath_id),
    CONSTRAINT fk_fsfile_fspath_id FOREIGN KEY (fspath_id) REFERENCES fspath (fspath_id)
) TYPE=InnoDB;
</source>

==== fsfile_type ====
* fsfile_type_id
* name
** command output
** patch
* desc
<source lang=sql>
CREATE TABLE fsfile_type (
    fsfile_type_id  INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== fspath_select ====
Default fsfile_path to save files for each rep_path and file_type.
* fspath_select_id
* fsfile_type_id
* rep_path_id
* fspath_id
<source lang=sql>
CREATE TABLE fspath_select (
    fspath_select_id    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    fsfile_type_id      INT UNSIGNED NOT NULL,
    rep_path_id         INT UNSIGNED NOT NULL,
    fspath_id           INT UNSIGNED NOT NULL,
    INDEX i_fsfile_type_id_rep_path_id (fsfile_type_id,rep_path_id),
    CONSTRAINT fk_fspath_select_fsfile_type_id FOREIGN KEY (fsfile_type_id) REFERENCES fsfile_type (fsfile_type_id),
    CONSTRAINT fk_fspath_select_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id),
    CONSTRAINT fk_fspath_select_fspath_id FOREIGN KEY (fspath_id) REFERENCES fspath (fspath_id)
) TYPE=InnoDB;
</source>

==== param_type ====
Types of parameters.
* param_type_id
* name
* desc
<source lang=sql>
CREATE TABLE param_type (
    param_type_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(20) NOT NULL,
    `desc`          TEXT DEFAULT NULL,
    INDEX i_name (name)
) TYPE=InnoDB;
</source>

==== param ====
Parameters values.
* param_id
* param_type_id
* value
<source lang=sql>
CREATE TABLE param (
    param_id        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    param_type_id   INT UNSIGNED NOT NULL,
    value           VARCHAR(255) DEFAULT NULL,
    INDEX i_name (param_type_id),
    CONSTRAINT fk_param_param_type_id FOREIGN KEY (param_type_id) REFERENCES param_type (param_type_id)
) TYPE=InnoDB;
</source>

=== Footer ===

<source lang=sql>
commit;
</source>
<!-- PARSE PART DBCREATE END -->

=== ToDo ===
* tests_num - plan, total tests which should have been run, null -> this isn't test file

=== Repository changes ===
* rev_num_from = 100, rev_num_to = 100 -> file inserted in rev 100 and deleted in 101
* rev_num_to = null - file exists in "max(rev_num) for rep_id"

==== A .. added (copied from) ====
* insert into rep_file, rev_num_from=rev_num, rev_num_to=null
* insert into rep_file_change
* insert into rep_file_change_from

==== M .. modified ====
* insert into rep_file_change

==== D .. deleted ====
* change rev_num_to

==== R .. replacing ====
* change rev_num_to to rev_num-1 for prev rep_file
* insert into rep_file, rev_num_from=rev_num, rev_num_to=null
* insert into rep_file_change
* insert into rep_file_change_from
