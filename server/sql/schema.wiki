=== Header ===

<!-- perl utils\wiki_schema.pl sql\schema.wiki 1 > sql\schema.sql -->
<!-- PARSE PART DBCREATE BEGIN -->
<source lang=sql>
-- schema version: 0.06
SET FOREIGN_KEY_CHECKS=0;
start transaction;
</source>

=== Tables ===

==== user ====
User info.
* user_id
* login
* passwd
* first_name
* last_name
* active - 0 means historical data
* created - account creation date
* last_login - date
<source lang=sql>
CREATE TABLE user (
    user_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    login       VARCHAR(20) NOT NULL,
    passwd      VARCHAR(20) NOT NULL,
    first_name  VARCHAR(255) NOT NULL DEFAULT '',
    last_name   VARCHAR(255) NOT NULL DEFAULT '',
    active      BOOLEAN NOT NULL DEFAULT 1,
    created     DATETIME NOT NULL,
    last_login  DATETIME DEFAULT NULL,
    INDEX i_login (login)
) TYPE=InnoDB;
</source>

==== machine (m) ====
machine (computer) info.
* machine_id
* user_id
* name
* passwd
* desc - description
* ip
* cpuarch
* osname
* archname
* disabled
* created
* prev_machine_id
<source lang=sql>
CREATE TABLE machine (
    machine_id      INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    user_id         INT UNSIGNED NOT NULL,
    name            VARCHAR(20) NOT NULL,
    passwd          VARCHAR(20) NOT NULL,
    `desc`          TEXT DEFAULT NULL,
    ip              VARCHAR(15) DEFAULT NULL,
    cpuarch         VARCHAR(50) DEFAULT NULL,
    osname          VARCHAR(50) DEFAULT NULL,
    archname        VARCHAR(255) DEFAULT NULL,
    disabled        BOOLEAN NOT NULL DEFAULT 0,
    created         DATETIME NOT NULL,
    prev_machine_id INT UNSIGNED DEFAULT NULL,
    farm_id         INT UNSIGNED DEFAULT NULL,
    CONSTRAINT fk_machine_user_id FOREIGN KEY (user_id) REFERENCES user (user_id),
    CONSTRAINT fk_machine_prev_machine_id FOREIGN KEY (prev_machine_id) REFERENCES machine (machine_id),
    CONSTRAINT fk_machine_farm_id FOREIGN KEY (farm_id) REFERENCES farm (farm_id)
) TYPE=InnoDB;
</source>

==== farm ====
Group of machines with same HW, SW or both configurations working in farm.
* farm_id
* name
* has_same_hw
* has_same_sw
* desc
<source lang=sql>
CREATE TABLE farm (
    farm_id         INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(20) NOT NULL,
    has_same_hw     BOOLEAN NOT NULL DEFAULT 0,
    has_same_sw     BOOLEAN NOT NULL DEFAULT 0,
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== project ====
Project.
* project_id
* name
* url
* desc
<source lang=sql>
CREATE TABLE project (
    project_id      INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(255) NOT NULL,
    url             VARCHAR(255) NOT NULL,
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== rep ====
Project repository. Each project can has only one active repository.
* rep_id
* project_id
* name
* path
* url
* desc
* active
<source lang=sql>
CREATE TABLE rep (
    rep_id      INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    project_id  INT UNSIGNED NOT NULL,
    name        VARCHAR(255) NOT NULL,
    path        VARCHAR(255) NOT NULL,
    url         VARCHAR(255) DEFAULT NULL,
    `desc`      TEXT DEFAULT NULL,
    active      BOOLEAN NOT NULL DEFAULT 1,
    CONSTRAINT fk_rep_project_id FOREIGN KEY (project_id) REFERENCES project (project_id),
    UNIQUE KEY unique_rep_id_path (rep_id, path)
) TYPE=InnoDB;
</source>

==== rep_author ====
Repository and patch authors. Some authors are also users.
* rep_author_id
* rep_id
* rep_login - can be null, see parrot rev 1346 created by cvs2svn
* user_id - some authors has TapTinder user_id too.
<source lang=sql>
CREATE TABLE rep_author (
    rep_author_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_id          INT UNSIGNED NOT NULL,
    rep_login       VARCHAR(255) DEFAULT NULL,
    user_id         INT UNSIGNED DEFAULT NULL,
    INDEX i_rep_id (rep_id),
    INDEX i_rep_login (rep_login),
    INDEX i_user_id (user_id),
    CONSTRAINT fk_user_rep_rep_id FOREIGN KEY (rep_id) REFERENCES rep (rep_id),
    CONSTRAINT fk_user_rep_user_id FOREIGN KEY (user_id) REFERENCES user (user_id)
) TYPE=InnoDB;
</source>

==== rev ====
Revision info.
* rev_id
* rep_id -- cache for rev_rep_path.rep_path_id -> rep_path.rep_id
* rev_num
* author_id
* date
* msg
<source lang=sql>
CREATE TABLE rev (
    rev_id          INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_id          INT UNSIGNED NOT NULL,
    rev_num         INT UNSIGNED NOT NULL,
    author_id       INT UNSIGNED NOT NULL,
    date            DATETIME NOT NULL,
    msg             TEXT,
    INDEX i_rep_id (rep_id),
    INDEX i_rev_num (rev_num),
    CONSTRAINT fk_rev_rep_id FOREIGN KEY (rep_id) REFERENCES rep (rep_id),
    CONSTRAINT fk_rev_rep_author_id FOREIGN KEY (author_id) REFERENCES rep_author (rep_author_id)
) TYPE=InnoDB;
</source>

==== rep_path ====
Repository path (trunk/, branch/pdd17pmc/, ...).
* rep_path_id
* rep_id
* path
* rev_num_from
* rev_num_to
<source lang=sql>
CREATE TABLE rep_path (
    rep_path_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_id          INT UNSIGNED NOT NULL,
    path            VARCHAR(255) NOT NULL,
    rev_num_from    INT UNSIGNED NOT NULL,
    rev_num_to      INT UNSIGNED DEFAULT NULL,
    INDEX i_rep_id (rep_id),
    INDEX i_path (path),
    INDEX i_rev_num_from (rev_num_from),
    INDEX i_rev_num_to (rev_num_to),
    CONSTRAINT fk_rep_path_rep_id FOREIGN KEY (rep_id) REFERENCES rep (rep_id)
) TYPE=InnoDB;
</source>

==== rev_rep_path ====
Revision info to repository path map (M:N).
* rev_id
* rep_path_id
<source lang=sql>
CREATE TABLE rev_rep_path (
    rev_id              INT UNSIGNED NOT NULL,
    rep_path_id         INT UNSIGNED NOT NULL,
    UNIQUE KEY unique_rep_id_path (rev_id, rep_path_id),
    INDEX i_rev_id_rep_path_id (rev_id, rep_path_id),
    CONSTRAINT fk_rev_rep_path_rev_id FOREIGN KEY (rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_rev_rep_path_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id)
) TYPE=InnoDB;
</source>

==== rep_file ====
Files in repository path.
* rep_file_id
* rep_path_id
* sub_path
* rev_num_from - revision where this file was added
* rev_num_to - revision number where this file was last seen (file was deleted in rev_to+1 revision)
<source lang=sql>
CREATE TABLE rep_file (
    rep_file_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_path_id     INT UNSIGNED NOT NULL,
    sub_path        VARCHAR(255) NOT NULL,
    rev_num_from    INT UNSIGNED NOT NULL,
    rev_num_to      INT UNSIGNED DEFAULT NULL,
    INDEX i_rep_path_id (rep_path_id),
    INDEX i_rev_num_from (rev_num_from),
    INDEX i_rev_num_to (rev_num_to),
    CONSTRAINT fk_rep_file_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id)
) TYPE=InnoDB;
</source>

==== rep_change_type ====
Change types and info.
* rep_change_type_id
* abbr
* desc
<source lang=sql>
CREATE TABLE rep_change_type (
    rep_change_type_id  INT UNSIGNED NOT NULL PRIMARY KEY,
    abbr                VARCHAR(1) NOT NULL,
    `desc`              VARCHAR(10) NOT NULL,
    INDEX i_abbr (abbr)
) TYPE=InnoDB;
</source>

==== rep_file_change ====
* rev_id
* rev_num - cache for rev.rev_num
* rep_file_id
* change_type_id
<source lang=sql>
CREATE TABLE rep_file_change (
    rev_id              INT UNSIGNED NOT NULL,
    rev_num             INT UNSIGNED NOT NULL,
    rep_file_id         INT UNSIGNED NOT NULL,
    change_type_id      INT UNSIGNED NOT NULL,
    INDEX i_rev_id (rev_id),
    INDEX i_rev_num (rev_num),
    INDEX i_rev_id_rep_file_id (rev_id, rep_file_id),
    CONSTRAINT fk_rep_file_change_rev_id FOREIGN KEY (rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_rep_file_change_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id),
    CONSTRAINT fk_rep_file_change_change_type_id FOREIGN KEY (change_type_id) REFERENCES rep_change_type (rep_change_type_id)
) TYPE=InnoDB;
</source>

==== rep_file_change_from ====
* rev_id
* rep_file_id
* from_rev_id
* from_rep_file_id
<source lang=sql>
CREATE TABLE rep_file_change_from (
    rev_id              INT UNSIGNED NOT NULL,
    rep_file_id         INT UNSIGNED NOT NULL,
    from_rev_id         INT UNSIGNED DEFAULT NULL,
    from_rep_file_id    INT UNSIGNED DEFAULT NULL,
    INDEX i_rev_id_rep_file_id (rev_id, rep_file_id),
    CONSTRAINT fk_rep_file_change_from_rev_id FOREIGN KEY (rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_rep_file_change_from_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id),
    CONSTRAINT fk_rep_file_change_from_from_rev_id FOREIGN KEY (from_rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_rep_file_change_from_from_rep_file_id FOREIGN KEY (from_rep_file_id) REFERENCES rep_file (rep_file_id)
) TYPE=InnoDB;
</source>

==== patch ====
Only one file for each patch.
* patch_id
* rep_path_id
* rev_num - revison number found in patch
* rev_num_to -- cache, server checks if patch apply ok
* author_id
* date
* msg
* file_id
* new_patch_id -- if not null then patch has newer version
<source lang=sql>
CREATE TABLE patch (
    patch_id        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_path_id     INT UNSIGNED NOT NULL,
    rev_num         INT UNSIGNED NOT NULL,
    rev_num_to      INT UNSIGNED NOT NULL,
    author_id       INT UNSIGNED NOT NULL,
    date            DATETIME NOT NULL,
    msg             TEXT,
    fsfile_id       INT UNSIGNED NOT NULL,
    new_patch_id    INT UNSIGNED DEFAULT NULL,
    INDEX i_rep_path_id (rep_path_id),
    INDEX i_rev_num (rev_num),
    CONSTRAINT fk_patch_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id),
    CONSTRAINT fk_patch_rep_author_id FOREIGN KEY (author_id) REFERENCES rep_author (rep_author_id),
    CONSTRAINT fk_patch_file_id FOREIGN KEY (fsfile_id) REFERENCES fsfile (fsfile_id),
    CONSTRAINT fk_patch_new_patch_id FOREIGN KEY (new_patch_id) REFERENCES patch (patch_id)
) TYPE=InnoDB;
</source>

==== rep_test ====
Number and name of the test. Each rep_file can contains many tests. Rep file gets new id after each file change.
* rep_test_id
* rep_file_id
* number -- this test number in rep_file
* name -- first inserted, name of the test (if any and not empty)
* has_another_name -- 1 if another name was found
<source lang=sql>
CREATE TABLE rep_test (
    rep_test_id         INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_file_id         INT UNSIGNED NOT NULL,
    number              INT UNSIGNED NOT NULL,
    name                VARCHAR(255) NOT NULL,
    has_another_name    BOOLEAN NOT NULL DEFAULT 0,
    INDEX i_rep_file_id (rep_file_id),
    INDEX i_rep_file_id_number (rep_file_id, number),
    CONSTRAINT fk_rep_test_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id)
) TYPE=InnoDB;
</source>

==== job ====
* job_id
* rep_id
* rep_path_id
* client_min_rev - minimal clietn revision number to run this job
* priority
* name
* desc
<source lang=sql>
CREATE TABLE job (
    job_id          INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    rep_id          INT UNSIGNED NOT NULL,
    rep_path_id     INT UNSIGNED DEFAULT NULL,
    client_min_rev  INT UNSIGNED DEFAULT 1,
    priority        INT UNSIGNED NOT NULL,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL,
    INDEX i_rep_id (rep_id),
    CONSTRAINT fk_job_rep_id FOREIGN KEY (rep_id) REFERENCES rep (rep_id),
    CONSTRAINT fk_job_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id)
) TYPE=InnoDB;
</source>

==== job_part ====
* job_part_id
* job_id
* order
* name
* desc
* depends_on_id - Depends on job_part.job_part_id. Job part (job_part_id) can't start if job_part.depends_on_id doesn't finished ok.
<source lang=sql>
CREATE TABLE job_part (
    job_part_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    job_id          INT UNSIGNED NOT NULL,
    `order`         INT UNSIGNED NOT NULL,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL,
    depends_on_id  INT UNSIGNED DEFAULT NULL,
    INDEX i_job_id (job_id),
    CONSTRAINT fk_job_part_job_id FOREIGN KEY (job_id) REFERENCES job (job_id),
    CONSTRAINT fk_job_part_depedns_on_id FOREIGN KEY (depends_on_id) REFERENCES job_part (job_part_id)
) TYPE=InnoDB;
</source>

==== command ====
* command_id
* name
* desc
Client should known what to run for each command_id. E.g. 1 (perlconf) means run 'perl Configure.pl' or 'perl.exe Configure.pl' (under win32).
<source lang=sql>
CREATE TABLE command (
    command_id      INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== job_part_command ====
* job_part_command_id
* job_part_id
* order
* command_id
* parameters
<source lang=sql>
CREATE TABLE job_part_command (
    job_part_command_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    job_part_id         INT UNSIGNED NOT NULL,
    `order`             INT UNSIGNED NOT NULL,
    command_id          INT UNSIGNED NOT NULL,
    parameters          TEXT,
    INDEX i_job_part_id (job_part_id),
    CONSTRAINT fk_job_part_command_job_part_id FOREIGN KEY (job_part_id) REFERENCES job_part (job_part_id),
    CONSTRAINT fk_job_part_command_command_id FOREIGN KEY (command_id) REFERENCES command (command_id)
) TYPE=InnoDB;
</source>

==== command_status ====
* command_status_id
* name
* 1 .. running
* 2 .. ok -- finished ok
* 3 .. interrupted
* 4 .. error -- finished with error
* desc
<source lang=sql>
CREATE TABLE command_status (
    command_status_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name                VARCHAR(25),
    `desc`              TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== machine_job_conf ====
* machine_job_conf_id
* machine_id
* rep_id
* rep_path_id
* job_id
<source lang=sql>
CREATE TABLE machine_job_conf (
    machine_job_conf_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    machine_id          INT UNSIGNED NOT NULL,
    rep_id              INT UNSIGNED NOT NULL,
    rep_path_id         INT UNSIGNED NOT NULL,
    job_id              INT UNSIGNED NOT NULL,
    INDEX i_machine_id (machine_id),
    CONSTRAINT fk_machine_job_conf_rep_id FOREIGN KEY (rep_id) REFERENCES rep_path (rep_id),
    CONSTRAINT fk_machine_job_conf_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id),
    CONSTRAINT fk_machine_job_conf_job_id FOREIGN KEY (job_id) REFERENCES rep_path (job_id)
) TYPE=InnoDB;
</source>

==== msession (ms) ====
Machine session. Each machine can run more than one processes at a time.
* msession_id
* machine_id
* client_rev - client revision (11, 10:12M, ...)
* pid - system process id on machine
* start_time - time when machine session was started
* end_time - time when machine session ended
* abort_reason_hid - default null, fk to msession_abort_reason
<source lang=sql>
CREATE TABLE msession (
    msession_id         INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    machine_id          INT UNSIGNED NOT NULL,
    client_rev          VARCHAR(21) NOT NULL,
    pid                 INT UNSIGNED NOT NULL,
    start_time          DATETIME NOT NULL,
    end_time            DATETIME DEFAULT NULL,
    abort_reason_id     INT UNSIGNED DEFAULT NULL,
    INDEX i_machine_id (machine_id),
    CONSTRAINT fk_msession_machine_id FOREIGN KEY (machine_id) REFERENCES machine (machine_id),
    CONSTRAINT fk_msession_abort_reason_id FOREIGN KEY (abort_reason_id) REFERENCES msabort_reason (msabort_reason_id)
) TYPE=InnoDB;
</source>

==== msjob ====
* msjob_id
* msession_id
* job_id
* pid
Abort reason is determined by msession.
<source lang=sql>
CREATE TABLE msjob (
    msjob_id            INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msession_id         INT UNSIGNED NOT NULL,
    job_id              INT UNSIGNED NOT NULL,
    pid                 INT UNSIGNED NOT NULL,
    INDEX i_msession_id (msession_id),
    INDEX i_job_id (job_id),
    CONSTRAINT fk_msjob_msession_id FOREIGN KEY (msession_id) REFERENCES msession (msession_id),
    CONSTRAINT fk_msjob_job_id FOREIGN KEY (job_id) REFERENCES job (job_id)
) TYPE=InnoDB;
</source>

==== msjob_command ====
* msjob_command_id
* job_command_id
* msjob_id
* command_status_id
* pid
* start_time
* end_time
* finished_ok
* output_id
<source lang=sql>
CREATE TABLE msjob_command (
    msjob_command_id    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    job_part_command_id INT UNSIGNED NOT NULL,
    msjob_id            INT UNSIGNED NOT NULL,
    status_id           INT UNSIGNED NOT NULL,
    pid                 INT UNSIGNED NOT NULL,
    start_time          DATETIME NOT NULL,
    end_time            DATETIME DEFAULT NULL,
    finished_ok         BOOLEAN NOT NULL,
    output_id           INT UNSIGNED NOT NULL,
    INDEX i_job_part_command_id (job_part_command_id),
    CONSTRAINT fk_msjob_command_job_part_command_id FOREIGN KEY (job_part_command_id) REFERENCES job_part_command (job_part_command_id),
    CONSTRAINT fk_msjob_command_msjob_id FOREIGN KEY (msjob_id) REFERENCES msjob (msjob_id),
    CONSTRAINT fk_msjob_command_job_status_id FOREIGN KEY (status_id) REFERENCES command_status (command_status_id),
    CONSTRAINT fk_msjob_command_output_id FOREIGN KEY (output_id) REFERENCES fsfile (fsfile_id)
) TYPE=InnoDB;
</source>
 
==== mslog ====
Machine session status. Could be part of msession table, but separate table is better for logging (and log cleaning).
* mslog_id
* msession_id
* msstatus_id
* attempt_number
* change_time - time when machine change msession state to this status_id
* finish_time - time when machine will probably change msession status again
** msstatus_id could stay same (waiting for new job) but attempt_number is increased
<source lang=sql>
CREATE TABLE mslog (
    mslog_id                INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msession_id             INT UNSIGNED NOT NULL,
    msstatus_id             INT UNSIGNED NOT NULL,
    attempt_number          INT UNSIGNED DEFAULT 1,
    change_time             DATETIME NOT NULL,
    estimated_finish_time   DATETIME DEFAULT NULL,
    INDEX i_msession_id (msession_id),
    CONSTRAINT fk_mslog_msession_id FOREIGN KEY (msession_id) REFERENCES msession (msession_id),
    CONSTRAINT fk_mslog_msstatus_id FOREIGN KEY (msstatus_id) REFERENCES msstatus (msstatus_id)
) TYPE=InnoDB;
</source>

==== msstatus ====
Machine session status messages.
* msstatus_id
* name - short status description
** 1 .. unknown status
** 2 .. msession just created
** 3 .. waiting for new job
** 4 .. running command
** 5 .. paused by user
** 6 .. stop by user
** 7 .. stop by web server -- see also msabort_reason table
** 8 .. stop by anything else
* desc - long description
<source lang=sql>
CREATE TABLE msstatus (
    msstatus_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== msabort_reason ====
Machine session status messages.
* msabort_reason_id
* name - short abort reason description
** 1 .. unknown reason
** 2 .. deprecated client revision
** 3 .. bad client behavior
** 4 .. iterrupted by client
* desc - long reason description
<source lang=sql>
CREATE TABLE msabort_reason (
    msabort_reason_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name                VARCHAR(25),
    `desc`              TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== build_conf ====
Build configurations.
* conf_id
* hash
* cc
* devel
* optimize
* alias_conf_id - another conf with the same semantics, but different syntax
<source lang=sql>
CREATE TABLE build_conf (
    build_conf_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    hash            VARCHAR(50) NOT NULL,
    cc              VARCHAR(255) DEFAULT NULL,
    devel           VARCHAR(255) DEFAULT NULL,
    `optimize`      VARCHAR(255) DEFAULT NULL,
    alias_conf_id   INT UNSIGNED DEFAULT NULL,
    INDEX i_hash (hash),
    CONSTRAINT fk_build_conf_alias_conf_id FOREIGN KEY (alias_conf_id) REFERENCES build_conf (build_conf_id)
) TYPE=InnoDB;
</source>

==== build ====
* build_id
* rep_path_id
* rev_id
* patch_id
* msjob_command_id
* conf_id - build configuration id
<source lang=sql>
CREATE TABLE build (
    build_id            INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msjob_command_id    INT UNSIGNED NOT NULL,
    rep_path_id         INT UNSIGNED NOT NULL,
    rev_id              INT UNSIGNED NOT NULL,
    patch_id            INT UNSIGNED DEFAULT NULL,
    conf_id             INT UNSIGNED NOT NULL,
    INDEX i_msjob_command_id (msjob_command_id),
    INDEX i_rev_id (rev_id),
    INDEX i_rep_path_id (rep_path_id),
    INDEX i_conf_id (conf_id),
    CONSTRAINT fk_build_msjob_command_id FOREIGN KEY (msjob_command_id) REFERENCES msjob_command (msjob_command_id),
    CONSTRAINT fk_build_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id),
    CONSTRAINT fk_build_rev_id FOREIGN KEY (rev_id) REFERENCES rev (rev_id),
    CONSTRAINT fk_build_patch_id FOREIGN KEY (patch_id) REFERENCES patch (patch_id),
    CONSTRAINT fk_build_conf_id FOREIGN KEY (conf_id) REFERENCES build_conf (build_conf_id)
) TYPE=InnoDB;
</source>

==== trun_conf ====
Test run configurations.
* trun_conf_id
* hash
* harness_args
* alias_conf_id - another conf with the same semantics, but different syntax
<source lang=sql>
CREATE TABLE trun_conf (
    trun_conf_id    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    hash            VARCHAR(50) NOT NULL,
    harness_args    VARCHAR(255) DEFAULT NULL,
    alias_conf_id   INT UNSIGNED DEFAULT NULL,
    INDEX i_hash (hash),
    CONSTRAINT fk_trun_conf_alias_conf_id FOREIGN KEY (alias_conf_id) REFERENCES trun_conf (trun_conf_id)
) TYPE=InnoDB;
</source>

==== trun ====
Test run info and test run statistics (cache).
* trun_id
* msjob_command_id
* build_id -- cache for build__msjob_id(build.msjob_command_id) == trun__msjob_id(trun.msjob_command_id)
* conf_id - test configuration id
* num_notseen -- cache
* num_failed -- cache
* num_unknown -- cache
* num_todo -- cache
* num_bonus -- cache
* num_skip -- cache
* num_ok -- cache
<source lang=sql>
CREATE TABLE trun (
    trun_id             INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msjob_command_id    INT UNSIGNED NOT NULL,
    build_id            INT UNSIGNED NOT NULL,
    conf_id             INT UNSIGNED NOT NULL,
    num_notseen         INT UNSIGNED NOT NULL,
    num_failed          INT UNSIGNED NOT NULL,
    num_unknown         INT UNSIGNED NOT NULL,
    num_todo            INT UNSIGNED NOT NULL,
    num_bonus           INT UNSIGNED NOT NULL,
    num_skip            INT UNSIGNED NOT NULL,
    num_ok              INT UNSIGNED NOT NULL,
    INDEX i_msjob_command_id (msjob_command_id),
    INDEX i_build_id (build_id),
    INDEX i_conf_id (conf_id),
    CONSTRAINT fk_trun_msjob_command_id FOREIGN KEY (msjob_command_id) REFERENCES msjob_command (msjob_command_id),
    CONSTRAINT fk_trun_build_id FOREIGN KEY (build_id) REFERENCES build (build_id),
    CONSTRAINT fk_trun_conf_id FOREIGN KEY (conf_id) REFERENCES trun_conf (trun_conf_id)
) TYPE=InnoDB;
</source>

==== brun_conf ====
Benchmark run.
* brun_conf_id
* hash
* args
* alias_conf_id - another conf with the same semantics, but different syntax
<source lang=sql>
CREATE TABLE brun_conf (
    brun_conf_id    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    hash            VARCHAR(50) NOT NULL,
    args            VARCHAR(255) DEFAULT NULL,
    alias_conf_id   INT UNSIGNED DEFAULT NULL,
    INDEX i_hash (hash),
    CONSTRAINT fk_brun_conf_alias_conf_id FOREIGN KEY (alias_conf_id) REFERENCES brun_conf (brun_conf_id)
) TYPE=InnoDB;
</source>

==== brun ====
* brun_id
* msjob_command_id
* build_id -- cache
* conf_id
<source lang=sql>
CREATE TABLE brun (
    brun_id             INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msjob_command_id    INT UNSIGNED NOT NULL,
    build_id            INT UNSIGNED NOT NULL,
    conf_id             INT UNSIGNED NOT NULL,
    INDEX i_msjob_command_id (msjob_command_id),
    INDEX i_build_id (build_id),
    INDEX i_conf_id (conf_id),
    CONSTRAINT fk_brun_msjob_command_id FOREIGN KEY (msjob_command_id) REFERENCES msjob_command (msjob_command_id),
    CONSTRAINT fk_brun_build_id FOREIGN KEY (build_id) REFERENCES build (build_id),
    CONSTRAINT fk_brun_conf_id FOREIGN KEY (conf_id) REFERENCES brun_conf (brun_conf_id)
) TYPE=InnoDB;
</source>

==== tskipall_msg ====
Reasons to skipp all tests.
* tskippall_msg_id
* msg
* hash
<source lang=sql>
CREATE TABLE tskipall_msg (
    tskipall_msg_id     INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    msg                 TEXT,
    hash                VARCHAR(50) NOT NULL,
    INDEX i_hash (hash)
) TYPE=InnoDB;
</source>

==== tfile ====
Test file summary results - summary result for all tests in file. All_passed is shortcup to data test.
* tfile_id
* trun_id
* rep_file_id
* all_passed -- (in Harness::Straps max == seen == ok)
* tskippall_msg_id (can be null)
* hang -- if test hang and was killed
<source lang=sql>
CREATE TABLE tfile (
    tfile_id            INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    trun_id             INT UNSIGNED NOT NULL,
    rep_file_id         INT UNSIGNED NOT NULL,
    all_passed          BOOLEAN NOT NULL DEFAULT 0,
    tskipall_msg_id     INT UNSIGNED DEFAULT NULL,
    hang                BOOLEAN DEFAULT 0,
    INDEX i_trun_id (trun_id),
    CONSTRAINT fk_tfile_trun_id FOREIGN KEY (trun_id) REFERENCES trun (trun_id),
    CONSTRAINT fk_tfile_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id),
    CONSTRAINT fk_tfile_tskipall_msg_id FOREIGN KEY (tskipall_msg_id) REFERENCES tskipall_msg (tskipall_msg_id)
) TYPE=InnoDB;
</source>

==== trest ====
Test result info. 
* tresult_id
* name
** 0 .. not seen
** 1 .. failed
** 2 .. unknown
** 3 .. todo
** 4 .. bonus -- unexpectedly succeeded
** 5 .. skip
** 6 .. ok
* desc
<source lang=sql>
CREATE TABLE trest (
    trest_id    INT UNSIGNED NOT NULL PRIMARY KEY,
    name        VARCHAR(25),
    `desc`      TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== ttest ====
Test results for each test (test case, subtest) submitted in trun.
* ttest_id
* trun_id
* rep_test_id
* trest_id
<source lang=sql>
CREATE TABLE ttest (
    ttest_id        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    trun_id         INT UNSIGNED NOT NULL,
    rep_test_id     INT UNSIGNED NOT NULL,
    trest_id        INT UNSIGNED NOT NULL,
    INDEX i_rep_test_id (rep_test_id),
    INDEX i_trun_id (trun_id),
    INDEX i_trest_id (trest_id),
    CONSTRAINT fk_ttest_trun_id FOREIGN KEY (trun_id) REFERENCES trun (trun_id),
    CONSTRAINT fk_ttest_rep_test_id FOREIGN KEY (rep_test_id) REFERENCES rep_test (rep_test_id),
    CONSTRAINT fk_ttest_trest_id FOREIGN KEY (trest_id) REFERENCES trest (trest_id)
) TYPE=InnoDB;
</source>

==== tdiag_msg ====
Diagnostic messages.
* tdiag_msg_id
* ttest_id
* msg
* hash
<source lang=sql>
CREATE TABLE tdiag_msg (
    tdiag_msg_id    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    ttest_id        INT UNSIGNED NOT NULL,
    msg             TEXT,
    hash            VARCHAR(50) NOT NULL,
    INDEX i_ttest_id (ttest_id),
    INDEX i_hash (hash),
    CONSTRAINT fk_tdiag_msg_ttest_id FOREIGN KEY (ttest_id) REFERENCES ttest (ttest_id)
) TYPE=InnoDB;
</source>

==== bfile ====
Bench file results.
* bfile_id
* brun_id
* rep_file_id
* run_time
* hang -- if test hang and was killed
<source lang=sql>
CREATE TABLE bfile (
    bfile_id            INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    brun_id             INT UNSIGNED NOT NULL,
    rep_file_id         INT UNSIGNED NOT NULL,
    run_time            INT UNSIGNED DEFAULT NULL,
    hang                BOOLEAN DEFAULT 0,
    INDEX i_brun_id (brun_id),
    CONSTRAINT fk_bfile_brun_id FOREIGN KEY (brun_id) REFERENCES brun (brun_id),
    CONSTRAINT fk_bfile_rep_file_id FOREIGN KEY (rep_file_id) REFERENCES rep_file (rep_file_id)
) TYPE=InnoDB;
</source>

==== fspath ====
List of directories with files.
* fspath_id
* path -- full path from root, e.g. /tmp/taptinder/patches/parrot-01/
* web_path
* public
* created
* deleted
* name
* desc
<source lang=sql>
CREATE TABLE fspath (
    fspath_id       INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    path            VARCHAR(1023),
    web_path        VARCHAR(255),
    public          BOOLEAN DEFAULT 0,
    created         DATETIME NOT NULL,
    deleted         DATETIME DEFAULT NULL,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== fsfile ====
List of saved files.
* fsfile_id
* fspath_id
* name
* size
* created
* deleted
<source lang=sql>
CREATE TABLE fsfile (
    fsfile_id       INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    fspath_id       INT UNSIGNED NOT NULL,
    name            VARCHAR(255),
    size            INT UNSIGNED NOT NULL,
    created         DATETIME NOT NULL,
    deleted         DATETIME DEFAULT NULL,
    INDEX i_fspath_id (fspath_id),
    CONSTRAINT fk_fsfile_fspath_id FOREIGN KEY (fspath_id) REFERENCES fspath (fspath_id)
) TYPE=InnoDB;
</source>

==== fsfile_type ===
* fsfile_type_id
* name
** command output
** patch
* desc
<source lang=sql>
CREATE TABLE fsfile_type (
    fsfile_type_id  INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(25),
    `desc`          TEXT DEFAULT NULL
) TYPE=InnoDB;
</source>

==== fspath_select ====
Default fsfile_path to save files for each rep_path and file_type.
* file_default_conf_id
* fsfile_type_id
* rep_path_id
* fspath_id
<source lang=sql>
CREATE TABLE fspath_select (
    fspath_select_id    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    fsfile_type_id      INT UNSIGNED NOT NULL,
    rep_path_id         INT UNSIGNED NOT NULL,
    fspath_id           INT UNSIGNED NOT NULL,
    INDEX i_fsfile_type_id_rep_path_id (fsfile_type_id,rep_path_id),
    CONSTRAINT fk_fspath_select_fsfile_type_id FOREIGN KEY (fsfile_type_id) REFERENCES fsfile_type (fsfile_type_id),
    CONSTRAINT fk_fspath_select_rep_path_id FOREIGN KEY (rep_path_id) REFERENCES rep_path (rep_path_id),
    CONSTRAINT fk_fsfile_default_conf_fspath_id FOREIGN KEY (fspath_id) REFERENCES fspath (fspath_id)
) TYPE=InnoDB;
</source>

==== param_type ====
Types of parameters.
* param_type_id
* name
* desc
<source lang=sql>
CREATE TABLE param_type (
    param_type_id   INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name            VARCHAR(20) NOT NULL,
    `desc`          TEXT DEFAULT NULL,
    INDEX i_name (name)
) TYPE=InnoDB;
</source>

==== param ====
Parameters values.
* param_id
* param_type_id
* value
<source lang=sql>
CREATE TABLE param (
    param_id        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    param_type_id   INT UNSIGNED NOT NULL,
    value           VARCHAR(255) DEFAULT NULL,
    INDEX i_name (param_type_id),
    CONSTRAINT fk_param_param_type_id FOREIGN KEY (param_type_id) REFERENCES param_type (param_type_id)
) TYPE=InnoDB;
</source>

=== Footer ===

<source lang=sql>
commit;
</source>
<!-- PARSE PART DBCREATE END -->

=== ToDo ===
* tests_num -- plan, total tests which should have been run, null -> this isn't test file

=== Repository changes ===
* rev_num_from = 100, rev_num_to = 100 -> file inserted in rev 100 and deleted in 101
* rev_num_to = null - file exists in "max(rev_num) for rep_id"

==== A .. added (copied from) ====
* insert into rep_file, rev_num_from=rev_num, rev_num_to=null
* insert into rep_file_change
* insert into rep_file_change_from

==== M .. modified ====
* insert into rep_file_change

==== D .. deleted ====
* change rev_num_to

==== R .. replacing ====
* change rev_num_to to rev_num-1 for prev rep_file
* insert into rep_file, rev_num_from=rev_num, rev_num_to=null
* insert into rep_file_change
* insert into rep_file_change_from
